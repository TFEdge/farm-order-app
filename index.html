<script>
    // --- CONFIG ---
    const API_URL = 'https://script.google.com/macros/s/AKfycby1OS6uT54RZRjVBNkBTzP8_EwXDEW338c9xuJqcRcTuPr068ruMfbti9itEyDkW8TI/exec'; // Replace with your deployed Apps Script URL

    // Map to hold references to all item cards (default and custom)
    const itemCardMap = new Map();
    let allOrdersCache = []; // Global variable to store fetched orders for sharing

    // --- Initialization and Event Listeners ---
    document.addEventListener('DOMContentLoaded', function() {
        // Populate the itemCardMap with default items
        document.querySelectorAll('.item-card').forEach(card => {
            const itemId = card.dataset.item;
            itemCardMap.set(itemId, card);
        });

        // Load all items (default prices and custom items) from the sheet
        loadAllItems();
        fetchAndDisplayAllOrders();

        // Add event listeners to all existing default item cards
        itemCardMap.forEach(card => addItemEventListeners(card));
        
        // Add Custom Item button listener
        document.getElementById('addCustomItem').addEventListener('click', addNewCustomItem);

        // Refresh Orders button listener
        document.getElementById('refreshOrders').addEventListener('click', function(e) {
            e.preventDefault();
            fetchAndDisplayAllOrders();
        });

        // Share Orders button listener
        document.getElementById('shareOrders').addEventListener('click', function(e) {
            e.preventDefault();
            shareOrders();
        });

        // Delete All Orders button listener
        document.getElementById('deleteAllOrdersBtn').addEventListener('click', function(e) {
            e.preventDefault();
            deleteAllOrders();
        });

        // Apply Discount button listener (NEW)
        document.getElementById('applyDiscountBtn').addEventListener('click', function(e) {
            e.preventDefault();
            applyOrderDiscount();
        });

        // Submit order button listener
        document.getElementById('submitOrder').addEventListener('click', function(e) {
            e.preventDefault();
            submitOrder();
        });
    });

    // --- Data Persistence ---

    /**
     * Fetches all items from the Apps Script and updates the UI.
     */
    async function loadAllItems() {
        try {
            const response = await fetch(API_URL, {
                redirect: "follow",
                method: 'POST',
                body: JSON.stringify({
                    action: 'getItems'
                }),
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8'
                }
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.success && result.result) {
                    const allItems = result.result;
                    allItems.forEach(item => {
                        // Check if it's a default item (already in the UI)
                        if (itemCardMap.has(item.id)) {
                            // Update default item price
                            updateDefaultItemUI(item.id, item.price);
                        } else if (item.id.startsWith('custom-')) {
                            // Add custom item to UI
                            addCustomItemToUI(item.id, item.name, item.price);
                        }
                    });
                    // Initial update of total for selected items (since price might have changed)
                    updateOrderTotal(); 
                } else {
                    console.error('API Error:', result.error);
                }
            } else {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            console.error('Error loading items:', error);
            alert('Failed to load item prices and custom items from the sheet.');
        }
    }

    /**
     * Updates the price input for a default item card with the persisted value.
     */
    function updateDefaultItemUI(itemId, price) {
        const card = itemCardMap.get(itemId);
        if (card) {
            card.querySelector('.price').value = price.toFixed(2);
        }
    }

    /**
     * Sends item data (name and/or price) to the Apps Script for saving.
     */
    async function saveItemData(itemId, itemName, itemPrice) {
        const itemData = { id: itemId };
        if (itemName !== undefined) itemData.name = itemName;
        if (itemPrice !== undefined) itemData.price = itemPrice;

        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                body: JSON.stringify({
                    action: 'savePrice', // Action to update/save item
                    item: itemData
                }),
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8'
                }
            });
            
            const result = await response.json();
            if (!response.ok || !result.success) {
                // NOTE: Changed alert to console.error as this is a background save operation
                console.error(`Error saving item ${itemId}:`, result.error || 'Failed to save item data.');
            } else {
                 console.log(`Item ${itemId} data saved successfully.`);
            }
        } catch (error) {
            console.error('Network Error saving item data:', error);
        }
    }

    // --- UI Management ---

    function addCustomItemToUI(itemId, itemName, price = 0.00) {
        const itemCard = document.createElement('div');
        itemCard.className = 'item-card';
        itemCard.dataset.item = itemId;
        
        itemCard.innerHTML = `
            <div class="item-card-header">
                <input type="text" class="item-name-input" value="${itemName}" data-original-name="${itemName}">
                <div class="price-display">
                    $ <input type="number" class="price" value="${price.toFixed(2)}" step="0.01">
                </div>
            </div>
            <div class="quantity-buttons">
                <button type="button" data-qty="1">1</button>
                <button type="button" data-qty="2">2</button>
                <button type="button" data-qty="3">3</button>
                <button type="button" data-qty="4">4</button>
                <button type="button" data-qty="5">5</button>
                <input type="number" class="other" placeholder="Other" step="1" min="0">
            </div>`;

        // Insert the new item before the Add Custom Item button
        const addCustomBtn = document.getElementById('addCustomItem');
        addCustomBtn.parentNode.insertBefore(itemCard, addCustomBtn);

        // Add to map and event listeners
        itemCardMap.set(itemId, itemCard);
        addItemEventListeners(itemCard);
    }

    async function addNewCustomItem() {
        const itemName = prompt('Enter item name:');
        if (!itemName) return;

        const customItemId = 'custom-' + Date.now();
        
        // Save the custom item first (name and initial price 0.00)
        await saveItemData(customItemId, itemName, 0.00);
        
        // If save is successful, add to UI
        addCustomItemToUI(customItemId, itemName, 0.00);
    }

    function addItemEventListeners(itemCard) {
        const itemId = itemCard.dataset.item;
        
        // 1. Quantity button listeners
        itemCard.querySelectorAll('.quantity-buttons button').forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                let quantity = parseFloat(this.dataset.qty);
                
                // For custom quantity input, update the value
                const otherInput = itemCard.querySelector('.quantity-buttons input.other');
                if (otherInput) otherInput.value = '';

                // Read the latest price from the input field
                const price = parseFloat(itemCard.querySelector('.price').value) || 0; 
                
                updateSelectedItems(itemId, quantity, price);
                
                itemCard.querySelectorAll('.quantity-buttons button').forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
            });
        });

        // 2. Other quantity input listener
        const otherInput = itemCard.querySelector('.quantity-buttons input.other');
        if (otherInput) {
            otherInput.addEventListener('input', function() {
                const quantity = parseFloat(this.value);
                // Read the latest price from the input field
                const price = parseFloat(itemCard.querySelector('.price').value) || 0; 
                if (!isNaN(quantity) && quantity >= 0) {
                    updateSelectedItems(itemId, quantity, price);
                } else if (!this.value) {
                    updateSelectedItems(itemId, 0, price); // Remove if input is cleared
                }
                itemCard.querySelectorAll('.quantity-buttons button').forEach(btn => btn.classList.remove('active'));
            });
        }
        
        // 3. Price input listener (Persists price change and updates order total)
        // FIX: Combined 'change' and 'input' to use 'input' for immediate save and update
        const priceInput = itemCard.querySelector('.price');
        if (priceInput) {
            priceInput.addEventListener('input', function() { // Using 'input' for immediate save and update
                const newPrice = parseFloat(this.value);
                
                // 3a. Save Price to Sheet (Only if valid number)
                if (!isNaN(newPrice)) {
                     saveItemData(itemId, undefined, newPrice);
                }
                
                // 3b. Update Selected Item Total (If item is currently selected)
                const selectedItem = document.querySelector(`.selected-item[data-item="${itemId}"]`);
                if (selectedItem) {
                    const qty = parseFloat(selectedItem.querySelector('.qty').textContent);
                    const priceToUse = isNaN(newPrice) ? 0 : newPrice;
                    updateSelectedItemTotal(selectedItem, qty, priceToUse);
                }
            });
        }
        
        // 4. Item Name input listener (Only for custom items, Persists name change)
        const nameInput = itemCard.querySelector('.item-name-input');
        if (nameInput) {
            nameInput.addEventListener('change', function() { // Use 'change' to save on blur
                const newName = this.value.trim();
                if (newName && newName !== this.dataset.originalName) {
                    saveItemData(itemId, newName, undefined);
                    this.dataset.originalName = newName; // FIXED: Corrected typo (original-name -> originalName)
                    // Update selected item name if it exists
                    const selectedItem = document.querySelector(`.selected-item[data-item="${itemId}"]`);
                    if(selectedItem) {
                        const qty = selectedItem.querySelector('.qty').textContent;
                        selectedItem.querySelector('span:first-child').innerHTML = `${newName} - Qty: <span class="qty">${qty}</span>`;
                    }
                }
            });
        }
    }

    // --- Helper Functions (No changes needed here, all correct) ---
    
    function updateSelectedItems(itemId, quantity, price) {
        const itemCard = itemCardMap.get(itemId);
        if (!itemCard) return;

        // Use the input for custom items, or the static H4 for default items
        const itemNameElement = itemCard.querySelector('.item-name-input') || itemCard.querySelector('h4');
        const itemName = itemNameElement.value || itemNameElement.textContent;
        
        let selectedList = document.getElementById('selectedItemsList');
        let existingItem = selectedList.querySelector(`[data-item="${itemId}"]`);
        
        if (quantity > 0) {
            if (existingItem) {
                updateSelectedItemTotal(existingItem, quantity, price);
            } else {
                addSelectedItem(itemId, itemName, quantity, price);
            }
        } else if (existingItem) {
            existingItem.remove();
        }
        
        updateOrderTotal();
    }

    function updateSelectedItemTotal(itemElement, quantity, price) {
        itemElement.querySelector('.qty').textContent = quantity;
        itemElement.querySelector('.total').textContent = (quantity * price).toFixed(2);
        updateOrderTotal();
    }

    function addSelectedItem(itemId, itemName, quantity, price) {
        const itemElement = document.createElement('div');
        itemElement.className = 'selected-item';
        itemElement.dataset.item = itemId;
        itemElement.innerHTML = `
            <span>${itemName} - Qty: <span class="qty">${quantity}</span></span>
            <span>$<span class="total">${(quantity * price).toFixed(2)}</span></span>
            <button class="remove-btn">Remove</button>
        `;
        
        document.getElementById('selectedItemsList').appendChild(itemElement);
        
        itemElement.querySelector('.remove-btn').addEventListener('click', () => {
            itemElement.remove();
            // Clear active state of quantity buttons
            const itemCard = itemCardMap.get(itemId);
            if (itemCard) {
                itemCard.querySelectorAll('.quantity-buttons button').forEach(btn => 
                    btn.classList.remove('active'));
                const otherInput = itemCard.querySelector('.quantity-buttons input.other');
                if (otherInput) otherInput.value = '';
            }
            updateOrderTotal();
        });
    }

    function updateOrderTotal() {
        const total = Array.from(document.querySelectorAll('.selected-item .total'))
            .reduce((sum, el) => sum + parseFloat(el.textContent), 0);
        document.getElementById('totalAmount').textContent = total.toFixed(2);
    }
    
    // --- Order Discount Logic (NOW SAVES TO SHEET) ---

    async function applyOrderDiscount() {
        const discountInput = document.getElementById('orderDiscount');
        const discount = parseFloat(discountInput.value);

        if (isNaN(discount) || discount < 0 || discount > 100) {
            alert('Please enter a valid discount percentage (0-100).');
            return;
        }

        const updatesToSend = []; // Array to collect all updates for the sheet

        // Apply discount to all displayed orders and prepare the update list
        document.querySelectorAll('.order-card').forEach(card => {
            const originalTotal = parseFloat(card.dataset.totalAmount);
            const adjustedTotal = originalTotal * (1 - discount / 100);
            
            // Update the display in the order card
            const adjustedTotalSpan = card.querySelector('.adjusted-total-display');
            if (adjustedTotalSpan) {
                adjustedTotalSpan.textContent = adjustedTotal.toFixed(2);
            }

            // Update the local cache for sharing (still needed)
            const sheetRow = parseInt(card.dataset.sheetRow);
            const orderInCache = allOrdersCache.find(o => o.sheetRow === sheetRow);
            if (orderInCache) {
                orderInCache.adjustedTotal = adjustedTotal;
            }

            // Add to the list of updates for the sheet
            updatesToSend.push({
                sheetRow: sheetRow,
                adjustedTotal: adjustedTotal.toFixed(2) // Send the new discounted total
            });
        });

        // --- NEW: Save the adjusted totals permanently to the sheet ---
        if (updatesToSend.length > 0) {
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    body: JSON.stringify({
                        action: 'updateAdjustedTotals', // NEW action handled by Apps Script
                        updates: updatesToSend
                    }),
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8'
                    }
                });

                const result = await response.json();
                if (response.ok && result.success) {
                    alert(`Order-level discount of ${discount}% applied and SAVED to the sheet for ${updatesToSend.length} orders.`);
                } else {
                     alert(`Discount applied locally, but FAILED to save to sheet: ${result.error || 'Unknown error.'}`);
                }
            } catch (error) {
                alert('Discount applied locally, but network error occurred while saving to sheet: ' + error.message);
            }
        } else {
            alert(`Order-level discount of ${discount}% applied to 0 displayed orders.`);
        }
    }

    /**
     * Processes cached orders, generates a summary message, and shares it via WhatsApp.
     */
    function shareOrders() {
        if (allOrdersCache.length === 0) {
            alert('Please refresh the orders first.');
            return;
        }

        // 1. Calculate Items Quantity Summary (Total across all orders)
        const itemQuantitySummary = new Map();
        const ordersByUser = new Map(); // Store parsed orders grouped by customer
        let grandTotal = 0;
        let grandAdjustedTotal = 0;

        allOrdersCache.forEach(order => {
            // Group individual orders
            if (!ordersByUser.has(order.customerName)) {
                ordersByUser.set(order.customerName, []);
            }
            
            const individualOrderItems = [];

            // Aggregate total quantity and prepare user order list
            Object.entries(order.items).forEach(([itemId, itemData]) => {
                const qty = itemData.quantity;
                
                // Get item name from UI map
                const itemNameElement = itemCardMap.get(itemId)?.querySelector('.item-name-input') || 
                                        itemCardMap.get(itemId)?.querySelector('h4');
                const itemName = (itemNameElement?.value || itemNameElement?.textContent || itemId).trim().replace(':', '');

                // Add to total quantity summary
                itemQuantitySummary.set(itemName, (itemQuantitySummary.get(itemName) || 0) + qty);
                
                // Add to individual user order list
                individualOrderItems.push(`${itemName} (${qty})`);
            });
            
            const adjustedTotal = order.adjustedTotal !== undefined ? order.adjustedTotal : order.totalAmount;

            ordersByUser.get(order.customerName).push({
                total: order.totalAmount,
                adjustedTotal: adjustedTotal, // NEW: Include adjusted total
                items: individualOrderItems.join('\n ')
            });
            
            grandTotal += order.totalAmount;
            grandAdjustedTotal += adjustedTotal;
        });

        // 2. Format the message
        let message = "üå± *Farm Order Summary* üå±\n\n";
        message += "--- Items Quantity Summary ---\n";
        
        // Total Items Summary
        itemQuantitySummary.forEach((qty, name) => {
            message += `‚Ä¢ ${name}: ${qty}\n`;
        });
        
        message += "\n--- Individual Orders ---\n";

        // Orders per user
        ordersByUser.forEach((orders, customerName) => {
            message += `*üë§ ${customerName}*\n`;
            orders.forEach(order => {
                message += `  ${order.items}\n`;
                message += `  - Total: $${order.total.toFixed(2)}`;
                if (order.adjustedTotal !== order.total) {
                    message += ` (Adj: $${order.adjustedTotal.toFixed(2)})`; // NEW: Add adjusted total to share message
                }
                message += `\n`;
            });
            message += "\n";
        });
        
        message += "--- Grand Totals ---\n";
        message += `Grand Total: $${grandTotal.toFixed(2)}\n`;
        message += `Grand Adjusted Total: $${grandAdjustedTotal.toFixed(2)}\n`; // NEW: Grand adjusted total

        // 3. Initiate WhatsApp Sharing
        const encodedMessage = encodeURIComponent(message);
        const whatsappUrl = `https://wa.me/?text=${encodedMessage}`;
        
        window.open(whatsappUrl, '_blank');
    }

    // --- All Orders / Sharing Logic ---

    /**
     * Fetches all orders from the Google Sheet and updates the display.
     */
    async function fetchAndDisplayAllOrders() {
        const refreshBtn = document.getElementById('refreshOrders');
        refreshBtn.textContent = 'Refreshing...';
        refreshBtn.disabled = true;
        const allOrdersList = document.getElementById('allOrdersList');
        allOrdersList.innerHTML = 'Loading orders...';

        // Clear any existing discount
        document.getElementById('orderDiscount').value = 0;

        try {
            const response = await fetch(API_URL, {
                redirect: "follow",
                method: 'POST',
                body: JSON.stringify({
                    action: 'getOrders'
                }),
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8'
                }
            });
            
            const result = await response.json();
            
            if (response.ok && result.success && Array.isArray(result.result)) {
                allOrdersCache = result.result; // Store for sharing
                allOrdersList.innerHTML = ''; // Clear loading message

                if (allOrdersCache.length === 0) {
                     allOrdersList.innerHTML = '<div class="setup-notice">No orders found in the sheet.</div>';
                }
                
                allOrdersCache.forEach(order => {
                    const orderCard = document.createElement('div');
                    orderCard.className = 'order-card';
                    // Convert timestamp to local date string for display
                    const date = new Date(order.timestamp).toLocaleString(); 
                    
                    // Detailed items list (formatted HTML for display)
                    const itemsHtml = Object.entries(order.items).map(([itemId, itemData]) => {
                        // Try to get the name from itemCardMap, or use the ID as a fallback
                        const itemNameElement = itemCardMap.get(itemId)?.querySelector('.item-name-input') || 
                                                itemCardMap.get(itemId)?.querySelector('h4');
                        const itemName = (itemNameElement?.value || itemNameElement?.textContent || itemId).trim().replace(':', ''); // Clean up name
                        return `<li>${itemName}: ${itemData.quantity} @ $${itemData.total.toFixed(2)}</li>`;
                    }).join('');

                    // Store total for discount calculation
                    orderCard.dataset.totalAmount = order.totalAmount;
                    orderCard.dataset.sheetRow = order.sheetRow; 
                    
                    // Use the adjusted total from the sheet if available, otherwise use totalAmount
                    const initialAdjustedTotal = order.adjustedTotal !== undefined ? order.adjustedTotal : order.totalAmount;

                    orderCard.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div>
                                <strong>Customer:</strong> ${order.customerName}<br>
                                <strong>Time:</strong> ${date}<br>
                                <strong>Total:</strong> $${order.totalAmount.toFixed(2)}<br>
                                <strong>Adjusted Total:</strong> <span class="adjusted-total-display adjusted-total">$${initialAdjustedTotal.toFixed(2)}</span>
                            </div>
                            <button class="remove-btn delete-order-btn" data-row="${order.sheetRow}">Delete</button>
                        </div>
                        <hr style="margin: 8px 0;">
                        <strong>Items:</strong>
                        <ul style="padding-left: 20px; margin: 5px 0 0;">${itemsHtml}</ul>
                    `;
                    allOrdersList.appendChild(orderCard);
                    
                    // Add event listener immediately after creating the button
                    orderCard.querySelector('.delete-order-btn').addEventListener('click', deleteIndividualOrderFrontend);
                });
            } else {
                console.error('API Error:', result.error || 'Failed to fetch orders.');
                allOrdersList.innerHTML = '<div class="setup-notice">Error fetching orders. Check console.</div>';
            }
        } catch (error) {
            console.error('Error fetching orders:', error);
            allOrdersList.innerHTML = '<div class="setup-notice">Network Error. Check API URL.</div>';
        } finally {
            refreshBtn.textContent = 'üîÑ Refresh Orders';
            refreshBtn.disabled = false;
        }
    }

    /**
     * Handles the deletion of a single order row via API call.
     */
    async function deleteIndividualOrderFrontend(event) {
        const button = event.currentTarget;
        const sheetRow = button.dataset.row;
        const customerName = button.closest('.order-card').querySelector('strong').nextSibling.textContent.trim();

        const confirmation = confirm(`Are you sure you want to delete the order for ${customerName}? (Row ${sheetRow})`);
        
        if (!confirmation) {
            return; 
        }

        button.textContent = 'Deleting...';
        button.disabled = true;

        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                body: JSON.stringify({
                    action: 'deleteIndividualOrder',
                    sheetRow: sheetRow
                }),
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8'
                }
            });
            
            const result = await response.json();
            
            if (response.ok && result.success) {
                alert(`Order for ${customerName} (Row ${sheetRow}) successfully deleted!`);
                // Visually remove the card and refresh the list to sync row numbers
                button.closest('.order-card').remove();
                
                // Re-run the fetch to get updated row numbers from the sheet, which is important
                fetchAndDisplayAllOrders(); 
            } else {
                alert('Failed to delete order: ' + (result.error || 'Unknown error.'));
            }
        } catch (error) {
            alert('Error communicating with the server: ' + error.message);
        } finally {
            // If the refresh call succeeds, this doesn't matter, but good practice:
            button.textContent = 'Delete';
            button.disabled = false;
        }
    }
            
    /**
     * Prompts user for double confirmation and sends request to delete all orders.
     */
    async function deleteAllOrders() {
        const confirmation = confirm("‚ö†Ô∏è WARNING: Are you sure you want to delete ALL orders? This action cannot be undone.");
        
        if (!confirmation) {
            return; // User cancelled the first prompt
        }

        const finalConfirmation = prompt("For final confirmation, type the word 'DELETE' (in all caps):");

        if (finalConfirmation !== 'DELETE') {
            alert("Deletion cancelled. Word was not typed correctly.");
            return;
        }

        const deleteBtn = document.getElementById('deleteAllOrdersBtn');
        deleteBtn.textContent = 'Deleting...';
        deleteBtn.disabled = true;

        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                body: JSON.stringify({
                    action: 'deleteAllOrders' // Action for Apps Script
                }),
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8'
                }
            });
            
            const result = await response.json();
            
            if (response.ok && result.success) {
                alert('‚úÖ All orders have been successfully deleted!');
                // Clear the display and refresh the orders list
                document.getElementById('allOrdersList').innerHTML = '<div class="setup-notice">No orders found in the sheet.</div>';
                allOrdersCache = []; // Clear local cache
            } else {
                alert('Failed to delete orders: ' + (result.error || 'Unknown error.'));
            }
        } catch (error) {
            alert('Error communicating with the server: ' + error.message);
        } finally {
            deleteBtn.textContent = 'üóëÔ∏è Delete ALL Orders';
            deleteBtn.disabled = false;
        }
    }

        // --- Order Submission ---
    async function submitOrder() {
        const customerName = document.getElementById('customerName').value.trim();
        if (!customerName) {
            alert('Please enter customer name');
            return;
        }

        const selectedItems = document.querySelectorAll('.selected-item');
        if (selectedItems.length === 0) {
            alert('Please select at least one item');
            return;
        }

        const order = {
            customerName: customerName,
            total: parseFloat(document.getElementById('totalAmount').textContent),
            items: {}
        };

        selectedItems.forEach(item => {
            const itemId = item.dataset.item;
            const qty = parseFloat(item.querySelector('.qty').textContent);
            const total = parseFloat(item.querySelector('.total').textContent);
            order.items[itemId] = {
                quantity: qty,
                total: total
            };
        });

        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                body: JSON.stringify({
                    action: 'addOrder',
                    order: order
                }),
                headers: {
                    'Content-Type': 'text/plain;charset=utf-8'
                }
            });
            
            const result = await response.json();
            if (response.ok && result.success) {
                alert('Order submitted successfully!');
                // Clear the form
                document.getElementById('customerName').value = '';
                document.getElementById('selectedItemsList').innerHTML = '';
                document.getElementById('totalAmount').textContent = '0.00';
                // Reset all quantity buttons/inputs
                document.querySelectorAll('.quantity-buttons button').forEach(btn => 
                    btn.classList.remove('active'));
                document.querySelectorAll('.quantity-buttons input.other').forEach(input => 
                    input.value = '');

                fetchAndDisplayAllOrders();
            } else {
                alert('Failed to submit order: ' + (result.error || 'Unknown error.'));
            }
        } catch (error) {
            alert('Error submitting order: ' + error.message);
        }
    }
</script>
